# v5. План проекта: API, Playwright и прокси в Docker

**Краткое summary:**  
Этот план описывает создание системы автоматизации браузеров с использованием Playwright в Docker, с акцентом на API, прокси и анти-детект возможности. Цель — разработать надежную, масштабируемую и незаметную для систем аналитики платформу для автоматизированных действий (например, проверка кодов на сайтах), имитируя поведение реального пользователя. Проект поэтапно раскрывает интеграцию API-сервера, менеджера прокси и контейнеризацию всей системы. Ключевые аспекты: изоляция каждой браузерной сессии, управление ресурсами, высокий уровень анти-детект техник (рандомизация отпечатка, эмуляция поведения пользователя).

---

## Основные принципы

- Работа только в Docker-контейнерах на headless сервере Ubuntu.
- Минимальный overhead и полная изоляция каждого запроса: каждый HTTP-запрос инициирует отдельную, полностью изолированную браузерную сессию для уникальности "цифрового следа".
- Использование только официальных Docker-образов и проверенных решений.
- Максимальная повторяемость и предсказуемость среды: все зависимости устанавливаются из Dockerfile.
- Высокий уровень анти-детект возможностей: рандомизация отпечатка, эмуляция живого поведения, обход аналитики и анти-бот систем.
- Прозрачность и воспроизводимость всех шагов и решений: только официальная документация, все команды должны работать "из коробки".

---

## Шаг 1: Базовая интеграция API-сервера и Playwright с учетом изоляции

- Определить структуру кода Fastify или Express для обработки HTTP-запросов, где каждый запрос инициирует запуск Playwright.
- Выбрать Playwright API (launch или connect) для запуска браузера с минимальным overhead и полной изоляцией.
- Уточнить: запускать новый процесс браузера (`playwright.chromium.launch()`) или создавать новый изолированный контекст (`browser.newContext`) для каждого запроса. Подтвердить, достаточно ли этого для изоляции (куки, localStorage и т.д.).
- Реализовать безопасную передачу данных из API-запроса (например, код/токен) в контекст Playwright-сценария.
- Реализовать механизм возврата результатов выполнения Playwright-сценария (успех/неудача, информация со страницы) обратно в обработчик API-запроса.
- Организовать код Node.js-скрипта для каждого HTTP-запроса: навигация, взаимодействие с элементами (например, ввод кода), извлечение результата. Использовать методы Playwright API (`page.goto`, `page.type`, `page.click`, `page.evaluate`, `page.locator`).
- Структурировать асинхронный код с использованием `await` для корректного ожидания всех операций Playwright.
- Настроить Playwright для работы в headless-режиме на Linux в Docker-контейнере. Передать необходимые параметры запуска для headless-режима.

---

## Шаг 2: Разработка и интеграция менеджера пула прокси с расширенной логикой

- Реализовать логику загрузки и хранения данных пула прокси (CSV/SQLite/БД).
- Обеспечить безопасный и эффективный доступ к данным прокси для API-сервера.
- Определить рекомендуемый способ хранения данных прокси (CSV, SQLite, внешняя БД — PostgreSQL/Redis), учитывая размер пула до 10 000 прокси и необходимость эффективного обновления статусов.
- Реализовать алгоритм выбора прокси для каждого нового браузерного сеанса, инициированного API-запросом. Учитывать параметры: "score", "fails", "last_failed", "active".
- Реализовать алгоритм расчета и обновления "score" прокси. Определить дополнительные факторы, влияющие на него.
- Реализовать динамическую передачу параметров прокси (IP, порт, тип SOCKS/HTTP, логин/пароль) в Playwright при запуске браузера для запроса. Определить формат строки прокси (например, `socks5://user:pass@ip:port`) или объект конфигурации Playwright. Привести пример кода для передачи параметров SOCKS-прокси с аутентификацией. Уточнить отличия для HTTP(S)-прокси.
- Реализовать механизм трекинга неудачных прокси.
- Определить условия, при которых прокси помечается как "битый" ("failed"), и алгоритм исключения из ротации, а также отслеживание времени возврата в пул.
- Реализовать обновление статуса прокси в хранилище (SQLite/CSV/БД) из Playwright-сценария или обработчика ошибок API при ошибках, связанных с прокси.
- Описать процесс передачи ошибки, идентифицированной как проблема прокси, обратно в обработчик API-запроса и инициировать обновление статуса прокси через менеджер.
- Минимизировать операции записи при сохранении обновленных статусов прокси, особенно при большом пуле и частых обновлениях.
- Реализовать перехват сетевых ошибок (таймауты, ошибки соединения) из-за неработающего прокси в Playwright-сценарии. Отличать ошибки прокси от ошибок целевого сайта или самого Playwright.
- Описать, как в Playwright-сценарии отличать ошибки логики сайта (например, неверный код) от ошибок прокси или Playwright, и как структурировать такие ошибки для возврата через API.

---

## Шаг 3: Контейнеризация с использованием Docker

- Определить рекомендуемую структуру папок для проекта: код API-сервера, Playwright-сценарии, файлы пула прокси (CSV/SQLite), Dockerfile.
- Создать полный, готовый к копированию Dockerfile на базе официального образа Ubuntu LTS Playwright (например, `mcr.microsoft.com/playwright:vX.Y.Z-jammy`). Dockerfile должен включать:
  - Установку Node.js и менеджера пакетов (npm/yarn/pnpm).
  - Копирование кода API-сервера и Playwright-сценариев.
  - Установку зависимостей (включая `@playwright/test` и библиотеку для работы с выбранным хранилищем прокси, например, SQLite).
  - Установку всех необходимых системных зависимостей браузеров (`npx playwright install --with-deps`).
  - Настройку запуска Node.js API-сервера как основного процесса контейнера.
  - Учет возможных проблем сборки нативных Node.js-модулей (например, `better-sqlite3`) — добавить необходимые шаги или конфигурации для успешной сборки.
- Создать пример `docker-compose.yml` (или эквивалентные команды `docker run`) для запуска контейнера:
  - Использовать собранный Dockerfile.
  - Настроить Docker Volume для маппинга локальной папки проекта внутрь контейнера (чтобы изменения кода были видны без пересборки).
  - Публиковать порт API-сервера на хост-машине.
  - (Опционально) Настроить подключение к внешнему хранилищу прокси (PostgreSQL/Redis), если не используется локальный файл.

---

## Шаг 4: Обработка ошибок, предсказуемость, управление ресурсами и анти-детект

- Сформировать стратегию обработки ошибок в связке "API-сервер <-> Playwright <-> Прокси". Отличать ошибки целевого сайта, прокси и самого Playwright.
- Обеспечить воспроизводимость выполнения Playwright-сценария для одного и того же входного кода (без прокси или с одним и тем же прокси).
- Проанализировать и реализовать механизмы эффективного управления ресурсами (память, CPU) при большом количестве параллельных запросов. Учитывать требование запуска отдельного браузера/контекста для каждого запроса.
- Программно ограничить максимальное количество параллельных браузерных сессий (процессов или контекстов Playwright), чтобы предотвратить исчерпание ресурсов сервера.
- Обеспечить полную изоляцию контекста браузера для каждого запроса (куки, localStorage и т.д.). Подтвердить, достаточно ли создания нового контекста или экземпляра браузера для этой изоляции.
- Требование к случайности контекста / управление цифровым отпечатком (fingerprint): каждый браузер/сессия должен быть случайным и уникальным (рандомизация Canvas, WebGL, шрифтов, HTTP-заголовков и т.д.) для каждого запроса.
- Требование к эмуляции живого поведения: Playwright-сценарии должны эмулировать реалистичное поведение пользователя (случайные задержки, движение мыши, скроллинг и т.д.).
- Исследовать и применить анти-детект техники или библиотеки (совместимые с Playwright, Linux/Docker, официальные, по возможности бесплатные), направленные на маскировку автоматизации и рандомизацию отпечатка. Ключевой показатель успеха — минимальный уровень обнаружения автоматизации.

---

**Документ структурирован, требования конкретны, все пункты реализуемы и проверяемы. Нет "душнилова", нет размытых советов, нет устаревших или неработающих решений.**
