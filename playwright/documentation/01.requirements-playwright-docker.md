# Описание задачи Автоматизация проверки кодов через Playwright в Docker

Основная цель — имитировать действия реального пользователя для массовой проверки данных, полученных по API, при этом минимизируя обнаружение автоматизированного трафика благодаря рандомизации цифрового отпечатка браузера, использованию пула прокси для каждого запроса и эмуляции естественного поведения пользователя. Важные требования включают работу исключительно внутри Docker, изоляцию каждого запроса для обеспечения уникальности "цифрового следа", и строгое следование проверенным решениям из официальной документации и экспертных сообществ.

## Контекст задачи

* Используем сервер Ubuntu **без GUI** (headless), где основной софт запускается исключительно в Docker-контейнерах.
* Цель: Автоматизировать массовую проверку кодов/токенов/кусков текста, получаемых из внешних скриптов (например, Google Apps Script), с помощью браузерной автоматизации через Playwright.
* Коды вводятся в web-чат/форму на целевом сайте.
* Запросы на проверку приходят по API — сценарий: внешний скрипт вызывает API, API инициирует Playwright-проверку в контейнере, возвращает результат.

## Описание задачи

* Используем сервер Ubuntu без GUI (headless), где основной софт запускается исключительно в Docker-контейнерах1.
* Цель: Автоматизировать массовую проверку кодов/токенов/кусков текста, получаемых из внешних скриптов (например, Google Apps Script), с помощью браузерной автоматизации через Playwright.
* Коды вводятся в web-чат/форму на целевом сайте1.
* Запросы на проверку приходят по API — сценарий: внешний скрипт вызывает API, API инициирует Playwright-проверку в контейнере, возвращает результат1.
* Дополнительная цель: Обеспечить, чтобы каждый запрос воспринимался целевым сайтом и его системами аналитики (например, GA4) как исходящий от нормального живого пользователя, минимизируя вероятность обнаружения автоматизированного трафика.

## Важные требования и ограничения

* **Всё работает внутри Docker** — никакого запуска чего-либо на хосте, никаких сторонних демонов вне контейнера.
* **Минимальный overhead**: Для каждого запроса запускается отдельный браузер, но основной сервис (сервер API) живёт постоянно, чтобы не плодить лишние контейнеры.
* **Playwright должен работать в headless-режиме, без GUI, на Linux.**
* **Вся файловая структура проекта (тесты, конфиги, server.js) должна жить в одном volume, чтобы легко обновлять через VSCode/SSH.**
* **Прокси для браузера**: На каждый новый запрос — новый прокси из пула, с быстрой ротацией. Пул может содержать до 10 000 прокси.
* **Прокси желательно украинские (мобильные предпочтительно), поддержка SOCKS/HTTP, иногда с логином/паролем.**
* **Менеджер пула прокси**: трекает неудачные прокси, исключает из ротации "битые" на время, пересчитывает рейтинг/score, хранит дату последней неудачи, количество фейлов, активность.
* **Хранение пула прокси**: Допускается хранение в SQLite или CSV, но должна быть возможность легко перейти на внешнюю БД (PostgreSQL/Redis) в будущем.
* **Серверный API на Fastify/Express** — поддержка запуска браузерных тестов по HTTP-запросу и возврат результатов.
* **Максимальная повторяемость/предсказуемость среды**: Все зависимости должны устанавливаться из Dockerfile, образы только официальные.
* **Жёсткие требования к честности и прозрачности (см. ЧИ!):**

  * Любые советы должны быть проверены на официальных ресурсах, документации, форумах Playwright, Node.js, Docker, StackOverflow.
  * Нельзя советовать устаревшее, неподдерживаемое, неработающее.
  * Всё должно быть описано в виде пошаговых инструкций, без "поищи, погугли, подбери".
  * Все команды — копипастятся и отрабатывают без доработки.
* Всё работает внутри Docker2....
* Минимальный overhead / Изоляция запросов: Основной сервис (сервер API) живёт постоянно2..., но для каждого входящего HTTP-запроса запускается отдельный, полностью изолированный браузер или контекст, чтобы обеспечить уникальность "цифрового следа" для каждого запроса и минимизировать накладные расходы2....
* Playwright должен работать в headless-режиме, без GUI, на Linux.2...
* Вся файловая структура проекта (тесты, конфиги, server.js) должна жить в одном volume, чтобы легко обновлять через VSCode/SSH2....
* Прокси для браузера: На каждый новый запрос — новый прокси из пула, с быстрой ротацией2.... Пул может содержать до 10 000 прокси2....
* Прокси желательно украинские (мобильные предпочтительно), поддержка SOCKS/HTTP, иногда с логином/паролем.2...
* Менеджер пула прокси: трекает неудачные прокси, исключает из ротации "битые" на время, пересчитывает рейтинг/score, хранит дату последней неудачи, количество фейлов, активность2.... Требуется эффективная загрузка и обновление статусов при большом пуле11.
* Хранение пула прокси: Допускается хранение в SQLite или CSV, но должна быть возможность легко перейти на внешнюю БД (PostgreSQL/Redis) в будущем2....
* Серверный API на Fastify/Express — поддержка запуска браузерных тестов по HTTP-запросу и возврат результатов2....
* Максимальная повторяемость/предсказуемость среды: Все зависимости должны устанавливаться из Dockerfile, образы только официальные2....
* Жёсткие требования к честности и прозрачности (см. ЧИ!): Любые советы должны быть проверены на официальных ресурсах, документации, форумах Playwright, Node.js, Docker, StackOverflow2.... Нельзя советовать устаревшее, неподдерживаемое, неработающее2.... Всё должно быть описано в виде пошаговых инструкций, без "поищи, погугли, подбери"2.... Все команды — копипастятся и отрабатывают без доработки2....
* Требование к случайности контекста / Управление цифровым отпечатком (Fingerprint): Контекст каждого запущенного браузера/сессии должен быть случайным и уникальным (помимо очистки куки и локального хранилища5...). Это включает рандомизацию параметров цифрового отпечатка браузера (например, Canvas, WebGL, шрифты, заголовки HTTP, Client Rects и т.д.) для каждого запроса, чтобы избежать идентификации как автоматизированного трафика или связывания запросов друг с другом.
* Требование к эмуляции живого поведения: Playwright сценарии должны не просто выполнять необходимые действия (ввод кода, клик13...), но и эмулировать реалистичное поведение пользователя на странице. Это может включать случайные задержки между действиями, имитацию движения курсора мыши, скроллинг страницы и другие неявные взаимодействия, которые делают трафик похожим на действия человека.
* Исследование и применение анти-детект техник: Необходимо исследовать возможность применения специализированных анти-детект техник или библиотек (при условии их совместимости с Playwright, Linux/Docker окружением и соблюдения требований к прозрачности, официальности и, по возможности, бесплатности/разумной стоимости), направленных на маскировку автоматизации и рандомизацию цифрового отпечатка.
Любой подход, инструкция, решение должны:
* Проверяться только на основании официальной документации, открытых обсуждений и опыта реальных пользователей из экспертных сообществ12....
* Быть применимы для headless-режима, работы внутри Docker, на Ubuntu Linux, без ручных доработок вне контейнера12....
* Поддерживать масштабируемое и быстрое обновление/ротацию пула прокси (CSV/SQLite/БД/Redis), хранение результатов и API-интеграцию12....
* Успешно обходить распространенные системы анти-бот и веб-аналитики (например, GA4), представляя каждый запрос как исходящий от уникального, реального пользователя путем рандомизации цифрового отпечатка браузера и эмуляции естественного поведения.
Дополнительное требование:
* Вся коммуникация, архитектурные решения, примеры кода должны быть максимально прозрачными и воспроизводимыми3....
* Ключевым показателем успеха является минимальный уровень обнаружения автоматизации системами аналитики/анти-бот, достигаемый за счет высокого уровня рандомизации контекста браузера и реалистичной эмуляции поведения.

## Примеры фильтрации информации

### Релевантно

* Playwright Docker usage for Ubuntu headless18.
* Fastify/Express API для запуска Playwright сценариев изнутри Docker18.
* Практики интеграции ротации прокси в браузерные автотесты18.
* Структура docker-compose.yml для нескольких сервисов (playwright-api, прокси-сервис, база)7....
* Проблемы сборки нативных модулей (better-sqlite3) под разные версии Node.js в Docker18....
* Использование только официальных тегов Playwright в Docker Hub/MCR12....
* Логика и структура менеджера прокси (поля: ip, port, type, country, region, city, score, fails, last_failed, active и т.д.)18.
* Алгоритмы исключения "битых" прокси и расчета "score"10....
* Перехват и различение ошибок прокси, ошибок целевого сайта и ошибок Playwright6....
* Эффективное управление ресурсами при параллельных запусках Playwright5....
* Техники рандомизации цифрового отпечатка браузера (browser fingerprinting) с использованием Playwright.
* Методы эмуляции реалистичного пользовательского поведения в Playwright.
* Исследование Playwright-совместимых библиотек или подходов для обхода систем анти-бот и веб-аналитики.
* Playwright Docker usage for Ubuntu headless
* Fastify/Express API для запуска Playwright сценариев изнутри Docker
* Практики интеграции ротации прокси в браузерные автотесты
* Структура docker-compose.yml для нескольких сервисов (playwright-api, прокси-сервис, база)
* Проблемы сборки нативных модулей (better-sqlite3) под разные версии Node.js
* Использование только официальных тегов Playwright в Docker Hub/MCR
* Логика и структура менеджера прокси (поля: ip, port, type, country, region, city, score, fails, last\_failed, active и т.д.)
* Алгоритмы исключения "битых" прокси

### Не релевантно

* Решения для Windows/Mac, GUI-режимы, запуск Playwright вне Docker15.
* Любые хаки, нестабильные образы, приватные/нерепрезентативные теги15.
* Обсуждение серверных библиотек, не совместимых с Ubuntu/Docker (например, не-Linux SQLite или устаревшие Node)15.
* Советы, не проверенные в официальной документации или на форумах12....
* Всё, что не копипастится и не даёт результат сразу12....
* Решения для Windows/Mac, GUI-режимы, запуск Playwright вне Docker
* Любые хаки, нестабильные образы, приватные/нерепрезентативные теги
* Обсуждение серверных библиотек, не совместимых с Ubuntu/Docker (например, не-Linux SQLite или устаревшие Node)
* Советы, не проверенные в официальной документации или на форумах
* Всё, что не копипастится и не даёт результат сразу

## Итог

**Любой подход, инструкция, решение должны:**

* Проверяться только на основании официальной документации, открытых обсуждений и опыта реальных пользователей из экспертных сообществ.
* Быть применимы для headless-режима, работы внутри Docker, на Ubuntu Linux, без ручных доработок вне контейнера.
* Поддерживать масштабируемое и быстрое обновление/ротацию пула прокси (CSV/SQLite/BД/Redis), хранение результатов и API-интеграцию.

**Дополнительное требование:**

* Вся коммуникация, архитектурные решения, примеры кода должны быть максимально прозрачными и воспроизводимыми.
